{"version":3,"sources":["../src/errors.ts","../src/http.ts","../src/utils/validation.ts","../src/client.ts"],"names":["MelonlyError","_MelonlyError","status","message","details","NetworkError","_NetworkError","cause","RateLimitError","_RateLimitError","retryAfterSeconds","resetTimestamp","ValidationError","_ValidationError","field","value","HttpClient","options","endpoint","params","url","data","cleanEndpoint","searchParams","key","queryString","lastError","attempt","error","delay","controller","timeoutId","headers","fetchOptions","response","contentType","responseBody","parseError","retryAfter","resetTime","errorMessage","ms","resolve","validateToken","token","validateId","id","fieldName","validatePaginationParams","MelonlyClient","applicationId","userId","loaId","memberId","logId","staffId","username","discordId","roleId","shiftId"],"mappings":"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","file":"index.mjs","sourcesContent":["/**\n * Base error class for all Melonly API errors\n */\nexport class MelonlyError extends Error {\n  public override readonly name: string = \"MelonlyError\";\n  public readonly timestamp = new Date().toISOString();\n\n  constructor(\n    public readonly status: number,\n    message: string,\n    public readonly details?: unknown,\n  ) {\n    super(message);\n    Object.setPrototypeOf(this, MelonlyError.prototype);\n  }\n\n  /**\n   * Convert error to JSON for logging/debugging\n   */\n  public toJSON(): Record<string, unknown> {\n    return {\n      name: this.name,\n      message: this.message,\n      status: this.status,\n      details: this.details,\n      timestamp: this.timestamp,\n      stack: this.stack,\n    };\n  }\n}\n\n/**\n * Network-related errors (timeouts, connection issues, etc.)\n */\nexport class NetworkError extends Error {\n  public override readonly name = \"NetworkError\";\n  public readonly timestamp = new Date().toISOString();\n\n  constructor(\n    message: string,\n    public readonly cause?: Error,\n  ) {\n    super(message);\n    Object.setPrototypeOf(this, NetworkError.prototype);\n  }\n\n  public toJSON(): Record<string, unknown> {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause?.message,\n      timestamp: this.timestamp,\n      stack: this.stack,\n    };\n  }\n}\n\n/**\n * Rate limiting errors with retry information\n */\nexport class RateLimitError extends MelonlyError {\n  public override readonly name: string = \"RateLimitError\";\n\n  constructor(\n    message: string,\n    public readonly retryAfterSeconds?: number,\n    public readonly resetTimestamp?: number,\n  ) {\n    super(429, message);\n    Object.setPrototypeOf(this, RateLimitError.prototype);\n  }\n\n  /**\n   * Get the time when the rate limit resets\n   */\n  get resetDate(): Date | undefined {\n    return this.resetTimestamp\n      ? new Date(this.resetTimestamp * 1000)\n      : undefined;\n  }\n\n  /**\n   * Get milliseconds until rate limit reset\n   */\n  get millisecondsUntilReset(): number | undefined {\n    if (!this.resetTimestamp) return undefined;\n    return Math.max(0, this.resetTimestamp * 1000 - Date.now());\n  }\n\n  public override toJSON(): Record<string, unknown> {\n    return {\n      ...super.toJSON(),\n      retryAfterSeconds: this.retryAfterSeconds,\n      resetTimestamp: this.resetTimestamp,\n      resetDate: this.resetDate?.toISOString(),\n      millisecondsUntilReset: this.millisecondsUntilReset,\n    };\n  }\n}\n\n/**\n * Validation errors for invalid input parameters\n */\nexport class ValidationError extends Error {\n  public override readonly name = \"ValidationError\";\n  public readonly timestamp = new Date().toISOString();\n\n  constructor(\n    message: string,\n    public readonly field?: string,\n    public readonly value?: unknown,\n  ) {\n    super(message);\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n\n  public toJSON(): Record<string, unknown> {\n    return {\n      name: this.name,\n      message: this.message,\n      field: this.field,\n      value: this.value,\n      timestamp: this.timestamp,\n      stack: this.stack,\n    };\n  }\n}\n\n/**\n * Type guard to check if an error is a Melonly API error\n */\nexport function isMelonlyError(error: unknown): error is MelonlyError {\n  return error instanceof MelonlyError;\n}\n\n/**\n * Type guard to check if an error is a network error\n */\nexport function isNetworkError(error: unknown): error is NetworkError {\n  return error instanceof NetworkError;\n}\n\n/**\n * Type guard to check if an error is a rate limit error\n */\nexport function isRateLimitError(error: unknown): error is RateLimitError {\n  return error instanceof RateLimitError;\n}\n\n/**\n * Type guard to check if an error is a validation error\n */\nexport function isValidationError(error: unknown): error is ValidationError {\n  return error instanceof ValidationError;\n}\n","import { MelonlyError, NetworkError, RateLimitError } from \"./errors\";\n\n/**\n * Configuration options for the HTTP client\n */\nexport interface HttpClientOptions {\n  baseUrl: string;\n  token: string;\n  timeout?: number;\n  maxRetries?: number;\n  debug?: boolean;\n  headers?: Record<string, string> | undefined;\n}\n\n/**\n * HTTP request options\n */\ninterface RequestOptions {\n  method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n  url: string;\n  headers?: Record<string, string>;\n  body?: unknown;\n  timeout?: number;\n}\n\n/**\n * Internal HTTP client with retry logic, timeout handling, and proper error handling\n */\nexport class HttpClient {\n  private readonly baseUrl: string;\n  private readonly token: string;\n  private readonly timeout: number;\n  private readonly maxRetries: number;\n  private readonly debug: boolean;\n  private readonly defaultHeaders: Record<string, string>;\n\n  constructor(options: HttpClientOptions) {\n    this.baseUrl = options.baseUrl.replace(/\\/$/, \"\"); // Remove trailing slash\n    this.token = options.token;\n    this.timeout = options.timeout ?? 30000;\n    this.maxRetries = options.maxRetries ?? 3;\n    this.debug = options.debug ?? false;\n    this.defaultHeaders = {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n      \"User-Agent\": \"@melonly/api-client/1.0.0\",\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Perform a GET request\n   */\n  async get<T>(endpoint: string, params?: Record<string, unknown>): Promise<T> {\n    const url = this.buildUrl(endpoint, params);\n    return this.request<T>({ method: \"GET\", url });\n  }\n\n  /**\n   * Perform a POST request\n   */\n  async post<T>(endpoint: string, data?: unknown): Promise<T> {\n    const url = this.buildUrl(endpoint);\n    return this.request<T>({ method: \"POST\", url, body: data });\n  }\n\n  /**\n   * Perform a PUT request\n   */\n  async put<T>(endpoint: string, data?: unknown): Promise<T> {\n    const url = this.buildUrl(endpoint);\n    return this.request<T>({ method: \"PUT\", url, body: data });\n  }\n\n  /**\n   * Perform a DELETE request\n   */\n  async delete<T>(endpoint: string): Promise<T> {\n    const url = this.buildUrl(endpoint);\n    return this.request<T>({ method: \"DELETE\", url });\n  }\n\n  /**\n   * Perform a PATCH request\n   */\n  async patch<T>(endpoint: string, data?: unknown): Promise<T> {\n    const url = this.buildUrl(endpoint);\n    return this.request<T>({ method: \"PATCH\", url, body: data });\n  }\n\n  /**\n   * Build URL with query parameters\n   */\n  private buildUrl(endpoint: string, params?: Record<string, unknown>): string {\n    const cleanEndpoint = endpoint.startsWith(\"/\") ? endpoint : `/${endpoint}`;\n    let url = `${this.baseUrl}${cleanEndpoint}`;\n\n    if (params && Object.keys(params).length > 0) {\n      const searchParams = new URLSearchParams();\n      Object.entries(params).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          searchParams.append(key, String(value));\n        }\n      });\n      const queryString = searchParams.toString();\n      if (queryString) {\n        url += `?${queryString}`;\n      }\n    }\n\n    return url;\n  }\n\n  /**\n   * Perform HTTP request with retry logic\n   */\n  private async request<T>(options: RequestOptions): Promise<T> {\n    let lastError: Error | undefined;\n\n    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {\n      try {\n        if (this.debug) {\n          console.log(\n            `[Melonly API] ${options.method} ${options.url} (attempt ${attempt})`,\n          );\n        }\n\n        const response = await this.performRequest(options);\n        return response as T;\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry on client errors (4xx), only on server errors (5xx) and network issues\n        if (error instanceof MelonlyError && error.status < 500) {\n          throw error;\n        }\n\n        // Don't retry on rate limits immediately - throw with retry info\n        if (error instanceof RateLimitError) {\n          throw error;\n        }\n\n        if (attempt === this.maxRetries) {\n          break;\n        }\n\n        // Exponential backoff with jitter\n        const delay =\n          Math.min(1000 * Math.pow(2, attempt - 1), 10000) +\n          Math.random() * 1000;\n\n        if (this.debug) {\n          console.log(`[Melonly API] Retrying after ${Math.round(delay)}ms...`);\n        }\n\n        await this.sleep(delay);\n      }\n    }\n\n    throw (\n      lastError ?? new NetworkError(\"Request failed after all retry attempts\")\n    );\n  }\n\n  /**\n   * Perform the actual HTTP request\n   */\n  private async performRequest<T>(options: RequestOptions): Promise<T> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n    try {\n      const headers = {\n        ...this.defaultHeaders,\n        Authorization: `Bearer ${this.token}`,\n        ...options.headers,\n      };\n\n      const fetchOptions: RequestInit = {\n        method: options.method,\n        headers,\n        signal: controller.signal,\n      };\n\n      if (options.body !== undefined) {\n        fetchOptions.body = JSON.stringify(options.body);\n      }\n\n      const response = await fetch(options.url, fetchOptions);\n      clearTimeout(timeoutId);\n\n      return await this.handleResponse<T>(response);\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error instanceof Error && error.name === \"AbortError\") {\n        throw new NetworkError(`Request timeout after ${this.timeout}ms`);\n      }\n\n      if (error instanceof TypeError && error.message.includes(\"fetch\")) {\n        throw new NetworkError(\n          \"Network request failed - please check your connection\",\n        );\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Handle HTTP response and parse JSON\n   */\n  private async handleResponse<T>(response: Response): Promise<T> {\n    const contentType = response.headers.get(\"content-type\") ?? \"\";\n\n    let responseBody: unknown;\n    try {\n      if (contentType.includes(\"application/json\")) {\n        responseBody = await response.json();\n      } else {\n        responseBody = await response.text();\n      }\n    } catch (parseError) {\n      throw new MelonlyError(response.status, \"Failed to parse response body\", {\n        originalError: parseError,\n      });\n    }\n\n    if (!response.ok) {\n      // Handle rate limiting\n      if (response.status === 429) {\n        const retryAfter = response.headers.get(\"retry-after\");\n        const resetTime = response.headers.get(\"x-ratelimit-reset\");\n        throw new RateLimitError(\n          \"Rate limit exceeded\",\n          retryAfter ? parseInt(retryAfter, 10) : undefined,\n          resetTime ? parseInt(resetTime, 10) : undefined,\n        );\n      }\n\n      // Extract error message from response body if available\n      let errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n      if (\n        responseBody &&\n        typeof responseBody === \"object\" &&\n        \"error\" in responseBody\n      ) {\n        errorMessage = String(responseBody.error);\n      }\n\n      throw new MelonlyError(response.status, errorMessage, responseBody);\n    }\n\n    return responseBody as T;\n  }\n\n  /**\n   * Sleep utility for retry delays\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n","import { ValidationError } from \"../errors\";\n\n/**\n * Validate API token format and presence\n */\nexport function validateToken(token: string): void {\n  if (!token) {\n    throw new ValidationError(\"API token is required\", \"token\", token);\n  }\n\n  if (typeof token !== \"string\") {\n    throw new ValidationError(\"API token must be a string\", \"token\", token);\n  }\n\n  if (token.trim().length === 0) {\n    throw new ValidationError(\"API token cannot be empty\", \"token\", token);\n  }\n\n  // Basic format validation - adjust based on actual token format requirements\n  if (token.length < 10) {\n    throw new ValidationError(\n      \"API token appears to be invalid (too short)\",\n      \"token\",\n      token,\n    );\n  }\n}\n\n/**\n * Validate ID parameters (non-empty strings)\n */\nexport function validateId(id: string, fieldName: string): void {\n  if (!id) {\n    throw new ValidationError(`${fieldName} is required`, fieldName, id);\n  }\n\n  if (typeof id !== \"string\") {\n    throw new ValidationError(`${fieldName} must be a string`, fieldName, id);\n  }\n\n  if (id.trim().length === 0) {\n    throw new ValidationError(`${fieldName} cannot be empty`, fieldName, id);\n  }\n\n  // Check for potentially problematic characters\n  if (id.includes(\"/\") || id.includes(\"?\") || id.includes(\"#\")) {\n    throw new ValidationError(\n      `${fieldName} contains invalid characters`,\n      fieldName,\n      id,\n    );\n  }\n}\n\n/**\n * Validate pagination parameters\n */\nexport function validatePaginationParams(params: {\n  page?: number;\n  limit?: number;\n}): void {\n  if (params.page !== undefined) {\n    if (!Number.isInteger(params.page) || params.page < 1) {\n      throw new ValidationError(\n        \"Page must be a positive integer starting from 1\",\n        \"page\",\n        params.page,\n      );\n    }\n\n    if (params.page > 10000) {\n      throw new ValidationError(\n        \"Page number is too large (maximum: 10000)\",\n        \"page\",\n        params.page,\n      );\n    }\n  }\n\n  if (params.limit !== undefined) {\n    if (!Number.isInteger(params.limit) || params.limit < 1) {\n      throw new ValidationError(\n        \"Limit must be a positive integer\",\n        \"limit\",\n        params.limit,\n      );\n    }\n\n    if (params.limit > 100) {\n      throw new ValidationError(\n        \"Limit cannot exceed 100 items per page\",\n        \"limit\",\n        params.limit,\n      );\n    }\n  }\n}\n\n/**\n * Validate URL format\n */\nexport function validateUrl(url: string, fieldName: string): void {\n  if (!url) {\n    throw new ValidationError(`${fieldName} is required`, fieldName, url);\n  }\n\n  if (typeof url !== \"string\") {\n    throw new ValidationError(`${fieldName} must be a string`, fieldName, url);\n  }\n\n  try {\n    new URL(url);\n  } catch {\n    throw new ValidationError(\n      `${fieldName} must be a valid URL`,\n      fieldName,\n      url,\n    );\n  }\n\n  if (!url.startsWith(\"https://\")) {\n    throw new ValidationError(`${fieldName} must use HTTPS`, fieldName, url);\n  }\n}\n\n/**\n * Validate timeout value\n */\nexport function validateTimeout(timeout: number): void {\n  if (!Number.isInteger(timeout) || timeout < 1000) {\n    throw new ValidationError(\n      \"Timeout must be an integer of at least 1000ms\",\n      \"timeout\",\n      timeout,\n    );\n  }\n\n  if (timeout > 300000) {\n    throw new ValidationError(\n      \"Timeout cannot exceed 300000ms (5 minutes)\",\n      \"timeout\",\n      timeout,\n    );\n  }\n}\n\n/**\n * Validate retry count\n */\nexport function validateRetryCount(retries: number): void {\n  if (!Number.isInteger(retries) || retries < 0) {\n    throw new ValidationError(\n      \"Retry count must be a non-negative integer\",\n      \"maxRetries\",\n      retries,\n    );\n  }\n\n  if (retries > 10) {\n    throw new ValidationError(\n      \"Retry count cannot exceed 10\",\n      \"maxRetries\",\n      retries,\n    );\n  }\n}\n","import { HttpClient } from \"./http\";\nimport type {\n  ApplicationAPIResponse,\n  ApplicationListResponse,\n  ApplicationResponseListResponse,\n  AuditLogListResponse,\n  JoinRequestAPIResponse,\n  JoinRequestListResponse,\n  LOAAPIResponse,\n  LOAListResponse,\n  LogAPIResponse,\n  LogListResponse,\n  MemberAPIResponse,\n  MemberListResponse,\n  RoleAPIResponse,\n  RoleListResponse,\n  ServerAPIResponse,\n  ShiftAPIResponse,\n  ShiftListResponse,\n} from \"./types\";\nimport {\n  validateId,\n  validatePaginationParams,\n  validateToken,\n} from \"./utils/validation\";\n\n/**\n * Configuration options for the Melonly client\n */\nexport interface ClientOptions {\n  /** API token for authentication */\n  token: string;\n  /** Base URL for the API (defaults to production) */\n  baseUrl?: string;\n  /** Request timeout in milliseconds (default: 30000) */\n  timeout?: number;\n  /** Maximum number of retry attempts (default: 3) */\n  maxRetries?: number;\n  /** Enable debug logging (default: false) */\n  debug?: boolean;\n  /** Custom headers to include with requests */\n  headers?: Record<string, string>;\n}\n\n/**\n * Pagination parameters for list endpoints\n */\nexport interface PaginationParams {\n  /** Page number (1-based) */\n  page?: number;\n  /** Number of items per page (1-100) */\n  limit?: number;\n  [key: string]: unknown;\n}\n\n/**\n * Official Melonly API client with full TypeScript support\n *\n * @example\n * ```typescript\n * import { MelonlyClient } from '@melonly/api-client';\n *\n * const client = new MelonlyClient({ token: 'your-api-token' });\n *\n * // Get server information\n * const serverInfo = await client.getServerInfo();\n *\n * // List applications with pagination\n * const applications = await client.getApplications({ page: 1, limit: 20 });\n * ```\n */\nexport class MelonlyClient {\n  private readonly http: HttpClient;\n\n  constructor(options: ClientOptions) {\n    validateToken(options.token);\n\n    this.http = new HttpClient({\n      baseUrl:\n        options.baseUrl ?? \"https://pubapitestingalphayes.melonly.xyz/api/v1\",\n      token: options.token,\n      timeout: options.timeout ?? 30000,\n      maxRetries: options.maxRetries ?? 3,\n      debug: options.debug ?? false,\n      headers: options.headers,\n    });\n  }\n\n  // --- Applications ---\n\n  /**\n   * Retrieve a paginated list of applications\n   * @param params - Pagination parameters\n   * @returns Promise resolving to application list with pagination info\n   */\n  async getApplications(\n    params: PaginationParams = {},\n  ): Promise<ApplicationListResponse> {\n    validatePaginationParams(params);\n    return this.http.get(\"/server/applications\", params);\n  }\n\n  /**\n   * Retrieve a specific application by ID\n   * @param applicationId - The application ID\n   * @returns Promise resolving to the application data\n   */\n  async getApplication(applicationId: string): Promise<ApplicationAPIResponse> {\n    validateId(applicationId, \"applicationId\");\n    return this.http.get(\n      `/server/applications/${encodeURIComponent(applicationId)}`,\n    );\n  }\n\n  /**\n   * Retrieve responses for a specific application\n   * @param applicationId - The application ID\n   * @param params - Pagination parameters\n   * @returns Promise resolving to application responses with pagination info\n   */\n  async getApplicationResponses(\n    applicationId: string,\n    params: PaginationParams = {},\n  ): Promise<ApplicationResponseListResponse> {\n    validateId(applicationId, \"applicationId\");\n    validatePaginationParams(params);\n    return this.http.get(\n      `/server/applications/${encodeURIComponent(applicationId)}/responses`,\n      params,\n    );\n  }\n\n  /**\n   * Retrieve application responses for a specific user\n   * @param userId - The user ID\n   * @param params - Pagination parameters\n   * @returns Promise resolving to user's application responses\n   */\n  async getUserApplicationResponses(\n    userId: string,\n    params: PaginationParams = {},\n  ): Promise<ApplicationResponseListResponse> {\n    validateId(userId, \"userId\");\n    validatePaginationParams(params);\n    return this.http.get(\n      `/server/applications/user/${encodeURIComponent(userId)}/responses`,\n      params,\n    );\n  }\n\n  // --- Audit Logs ---\n\n  /**\n   * Retrieve a paginated list of audit logs\n   * @param params - Pagination parameters\n   * @returns Promise resolving to audit logs with pagination info\n   */\n  async getAuditLogs(\n    params: PaginationParams = {},\n  ): Promise<AuditLogListResponse> {\n    validatePaginationParams(params);\n    return this.http.get(\"/server/audit-logs\", params);\n  }\n\n  // --- Server Info ---\n\n  /**\n   * Retrieve server information\n   * @returns Promise resolving to server information\n   */\n  async getServerInfo(): Promise<ServerAPIResponse> {\n    return this.http.get(\"/server/info\");\n  }\n\n  // --- Join Requests ---\n\n  /**\n   * Retrieve a paginated list of join requests\n   * @param params - Pagination parameters\n   * @returns Promise resolving to join requests with pagination info\n   */\n  async getJoinRequests(\n    params: PaginationParams = {},\n  ): Promise<JoinRequestListResponse> {\n    validatePaginationParams(params);\n    return this.http.get(\"/server/join-requests\", params);\n  }\n\n  /**\n   * Retrieve a specific join request by user ID\n   * @param userId - The user ID\n   * @returns Promise resolving to the join request data\n   */\n  async getJoinRequest(userId: string): Promise<JoinRequestAPIResponse> {\n    validateId(userId, \"userId\");\n    return this.http.get(`/server/join-requests/${encodeURIComponent(userId)}`);\n  }\n\n  // --- LOAs (Leave of Absence) ---\n\n  /**\n   * Retrieve a paginated list of LOAs\n   * @param params - Pagination parameters\n   * @returns Promise resolving to LOAs with pagination info\n   */\n  async getLOAs(params: PaginationParams = {}): Promise<LOAListResponse> {\n    validatePaginationParams(params);\n    return this.http.get(\"/server/loas\", params);\n  }\n\n  /**\n   * Retrieve a specific LOA by ID\n   * @param loaId - The LOA ID\n   * @returns Promise resolving to the LOA data\n   */\n  async getLOA(loaId: string): Promise<LOAAPIResponse> {\n    validateId(loaId, \"loaId\");\n    return this.http.get(`/server/loas/${encodeURIComponent(loaId)}`);\n  }\n\n  /**\n   * Retrieve LOAs for a specific member\n   * @param memberId - The member ID\n   * @param params - Pagination parameters\n   * @returns Promise resolving to member's LOAs\n   */\n  async getUserLOAs(\n    memberId: string,\n    params: PaginationParams = {},\n  ): Promise<LOAListResponse> {\n    validateId(memberId, \"memberId\");\n    validatePaginationParams(params);\n    return this.http.get(\n      `/server/loas/user/${encodeURIComponent(memberId)}`,\n      params,\n    );\n  }\n\n  // --- Logs ---\n\n  /**\n   * Retrieve a paginated list of logs\n   * @param params - Pagination parameters\n   * @returns Promise resolving to logs with pagination info\n   */\n  async getLogs(params: PaginationParams = {}): Promise<LogListResponse> {\n    validatePaginationParams(params);\n    return this.http.get(\"/server/logs\", params);\n  }\n\n  /**\n   * Retrieve a specific log by ID\n   * @param logId - The log ID\n   * @returns Promise resolving to the log data\n   */\n  async getLog(logId: string): Promise<LogAPIResponse> {\n    validateId(logId, \"logId\");\n    return this.http.get(`/server/logs/${encodeURIComponent(logId)}`);\n  }\n\n  /**\n   * Retrieve logs created by a specific staff member\n   * @param staffId - The staff member ID\n   * @param params - Pagination parameters\n   * @returns Promise resolving to staff member's logs\n   */\n  async getStaffLogs(\n    staffId: string,\n    params: PaginationParams = {},\n  ): Promise<LogListResponse> {\n    validateId(staffId, \"staffId\");\n    validatePaginationParams(params);\n    return this.http.get(\n      `/server/logs/staff/${encodeURIComponent(staffId)}`,\n      params,\n    );\n  }\n\n  /**\n   * Retrieve logs for a specific user\n   * @param username - The username\n   * @param params - Pagination parameters\n   * @returns Promise resolving to user's logs\n   */\n  async getUserLogs(\n    username: string,\n    params: PaginationParams = {},\n  ): Promise<LogListResponse> {\n    if (!username?.trim()) {\n      throw new Error(\"Username is required and cannot be empty\");\n    }\n    validatePaginationParams(params);\n    return this.http.get(\n      `/server/logs/user/${encodeURIComponent(username)}`,\n      params,\n    );\n  }\n\n  // --- Members ---\n\n  /**\n   * Retrieve a paginated list of server members\n   * @param params - Pagination parameters\n   * @returns Promise resolving to members with pagination info\n   */\n  async getMembers(params: PaginationParams = {}): Promise<MemberListResponse> {\n    validatePaginationParams(params);\n    return this.http.get(\"/server/members\", params);\n  }\n\n  /**\n   * Retrieve a specific member by ID\n   * @param memberId - The member ID\n   * @returns Promise resolving to the member data\n   */\n  async getMember(memberId: string): Promise<MemberAPIResponse> {\n    validateId(memberId, \"memberId\");\n    return this.http.get(`/server/members/${encodeURIComponent(memberId)}`);\n  }\n\n  /**\n   * Retrieve a member by their Discord ID\n   * @param discordId - The Discord user ID\n   * @returns Promise resolving to the member data\n   */\n  async getMemberByDiscordId(discordId: string): Promise<MemberAPIResponse> {\n    validateId(discordId, \"discordId\");\n    return this.http.get(\n      `/server/members/discord/${encodeURIComponent(discordId)}`,\n    );\n  }\n\n  // --- Roles ---\n\n  /**\n   * Retrieve a paginated list of roles\n   * @param params - Pagination parameters\n   * @returns Promise resolving to roles with pagination info\n   */\n  async getRoles(params: PaginationParams = {}): Promise<RoleListResponse> {\n    validatePaginationParams(params);\n    return this.http.get(\"/server/roles\", params);\n  }\n\n  /**\n   * Retrieve a specific role by ID\n   * @param roleId - The role ID\n   * @returns Promise resolving to the role data\n   */\n  async getRole(roleId: string): Promise<RoleAPIResponse> {\n    validateId(roleId, \"roleId\");\n    return this.http.get(`/server/roles/${encodeURIComponent(roleId)}`);\n  }\n\n  // --- Shifts ---\n\n  /**\n   * Retrieve a paginated list of shifts\n   * @param params - Pagination parameters\n   * @returns Promise resolving to shifts with pagination info\n   */\n  async getShifts(params: PaginationParams = {}): Promise<ShiftListResponse> {\n    validatePaginationParams(params);\n    return this.http.get(\"/server/shifts\", params);\n  }\n\n  /**\n   * Retrieve a specific shift by ID\n   * @param shiftId - The shift ID\n   * @returns Promise resolving to the shift data\n   */\n  async getShift(shiftId: string): Promise<ShiftAPIResponse> {\n    validateId(shiftId, \"shiftId\");\n    return this.http.get(`/server/shifts/${encodeURIComponent(shiftId)}`);\n  }\n}\n"]}